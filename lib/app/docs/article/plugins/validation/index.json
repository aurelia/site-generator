{"name":"Validation","description":"The basics of validation with Aurelia.","author":{"name":"Jeremy Danyow","url":"http://danyow.net"},"keywords":["Validation","Data Binding","JavaScript","TypeScript"],"contributors":[],"translators":[],"links":{"static":"docs/article/plugins/validation","html":"docs/article/plugins/validation/index.html","fragment":"docs/article/plugins/validation/index-fragment.html","self":"docs/article/plugins/validation/index.json"},"content":"\r\n\r\n## [Introduction](aurelia-doc://section/1/version/1.0.0)\r\n\r\nThis article covers the basics of validation with Aurelia's validation plugin. You'll learn how to add validation to your applications using a fluent rule API and minimal changes to your templates.\r\n\r\nTo get started you'll need to install `aurelia-validation` using `jspm install aurelia-validation` or `npm install aurelia-validation --save`. Afterwards, add `.plugin('aurelia-validation')` to the configuration in your `main.js` to ensure the plugin is loaded at application startup.\r\n\r\nIf you're using the `aurelia-cli`, add the following configuration to your `aurelia.json` after you've installed the package with npm.\r\n\r\n<code-listing heading=\"aurelia.json\">\r\n  <source-code lang=\"ES 2015\">\r\n    {\r\n      \"name\": \"aurelia-validation\",\r\n      \"path\": \"../node_modules/aurelia-validation/dist/amd\",\r\n      \"main\": \"aurelia-validation\"\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nIf you're not sure where to put this, search your `aurelia.json` for *aurelia-templating-resources* and put it underneath.\r\n\r\n## [Defining Rules](aurelia-doc://section/2/version/1.0.0)\r\n\r\nAurelia Validation's standard rule engine uses a fluent syntax to define a set of rules. There are five parts to the syntax:\r\n1. Selecting a property using `.ensure`\r\n2. Associating rules with the property using `.required`, `.matches`, etc\r\n3. Customizing property rules using `.withMessage`, `.when`, etc\r\n4. Sequencing rules using `.then`\r\n5. Applying the ruleset to a class or instance using `.on`\r\n\r\n### ensure\r\n\r\nTo begin defining a ruleset, use the `ValidationRules` class. Start by targeting a property using `ValidationRules.ensure(...)`. The `ensure` method accepts one argument representing the property name. The argument can be a string or a simple property access expression. If you're using TypeScript you'll probably want to use a property access expression because you'll get the benefit of intellisense, refactoring and avoid using \"magic strings\" that can be a maintenance issue.\r\n\r\n<code-listing heading=\"Ensure\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules\r\n      .ensure('firstName')...\r\n\r\n    ValidationRules\r\n      .ensure(p => p.firstName)...\r\n  </source-code>\r\n  <source-code lang=\"TypeScript\">\r\n    ValidationRules\r\n      .ensure('firstName')...\r\n\r\n    ValidationRules\r\n      .ensure((p: Person) => p.firstName)...\r\n  </source-code>\r\n</code-listing>\r\n\r\n### displayName\r\n\r\nOnce you've targetted a property using `ensure` you can define the property's display name using `.displayName(name: string|ValidationDisplayNameAccessor)`. Display names are used in validation messages. Specifying a display name is optional. If you do not explicitly set the display name the validation engine will attempt to compute the display name for you by splitting the property name on upper-case letters. A `firstName` property's display name would be `First Name`.\r\n\r\n<code-listing heading=\"displayName\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules      \r\n      .ensure('ssn').displayName('SSN')...\r\n  </source-code>\r\n</code-listing>\r\n\r\n### Applying Rules\r\n\r\nAfter targeting a property with `ensure` and optionally setting its display name you can begin associating rules with the property using the built-in rule methods:\r\n\r\n* `required()` validates the property is not null, undefined or whitespace.\r\n* `matches(regex)` validates the property matches the specified regular expression.\r\n* `email()` validates an email address.\r\n* `minLength(length)` and `maxLength(length)` validate the length of string properties.\r\n* `minItems(count)` and `maxItems(count)` validate the number of items in an array.\r\n* `equals(expectedValue)` validates the property equals the expected value.\r\n* `satisfies((value: any, object?: any) => boolean|Promise<boolean>)` validates the supplied function returns `true` or a `Promise` that resolves to `true`. The function will be invoked with two arguments:\r\n  * the property's current value.\r\n  * the object the property belongs to.\r\n\r\n### withMessage\r\n\r\nAll rules have a standard message that can be overriden on a case-by-case basis using `.withMessage(message)`. The `message` argument is a string that will be interpreted as an interpolation binding expression and evaluated against the validated object when a validation error occurs. The interpolation binding expression can access any of the object's properties as well as the contextual properties listed below:\r\n\r\n* `$displayName`: the display name of the property.\r\n* `$propertyName`: the name of the property.\r\n* `$value`: the property value (at the moment the validation rule was executed).\r\n* `$object`: the object that owns the property.\r\n* `$config`: an object containing the rule's configuration. For example, the config for a `minLength` rule will have a `length` property.\r\n* `$getDisplayName`:  returns a displayable name of a property given the property name (irrespective of the property's displayName), split on capital letters, first letter ensured to be capitalized.\r\n\r\nHere's an example:\r\n\r\n<code-listing heading=\"withMessage\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules      \r\n      .ensure('ssn').displayName('SSN')\r\n        .required().withMessage(`\\${$displayName} cannot be blank.`);\r\n        .matches(/\\d{3}-\\d{2}-\\d{4}/).withMessage(`\\\"${$value}\" is not a valid \\${$displayName}.`);\r\n  </source-code>\r\n</code-listing>\r\n\r\n### withMessageKey\r\n\r\nAnother way to override messages on a case-by-case basis is to use the `.withMessageKey(key)` fluent API. Key is a string representing a key in the `validationMessages` dictionary. You can add new keys to the dictionary using the following code:\r\n\r\n<code-listing heading=\"withMessageKey\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {validationMessages} from 'aurelia-validation';\r\n\r\n    validationMessages['invalidAirportCode'] = `\\${$displayName} is not a valid airport code.`;\r\n\r\n    ValidationRules\r\n      .ensure('airportCode')\r\n        .matches(/^[A-Z]{3}$/).withMessageKey('invalidAirportCode')...\r\n  </source-code>\r\n</code-listing>\r\n\r\n### Conditional Validation\r\n\r\nYou may run into situations where you only want a rule to be evaluated when certain conditions are met. Use the `.when(condition: (object) => boolean)` fluent API to define a condition that must be met before the rule is evaluated. `when` accepts one argument, a function that takes the object and returns a boolean that indicates whether the rule should (`true`) or should not (`false`) be evaluated.\r\n\r\n<code-listing heading=\"Conditional Validation\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules\r\n      .ensure('email')\r\n        .email()\r\n        .required()\r\n          .when(order => order.shipmentNotifications)\r\n          .withMessage('Email is required when shipment notifications have been requested.');\r\n  </source-code>\r\n</code-listing>\r\n\r\n### Sequencing Rule Evaluation\r\n\r\nRules are evaluated in parallel. Use the `.then()` method to postpone evaluation of a rule until after the preceding rules in the `ensure` have been evaluated.\r\n\r\n<code-listing heading=\"Conditional Validation\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules\r\n      .ensure('email')\r\n        .email()\r\n        .required()\r\n        .then()\r\n        .satisfiesRule('emailNotAlreadyRegistered')\r\n      .ensure('username')\r\n        .required()\r\n        .minLength(3)\r\n        .maxLength(50)\r\n        .then()\r\n        .satisfiesRule('usernameNotInUse');\r\n  </source-code>\r\n</code-listing>\r\n\r\nIn the example above, the `emailNotAlreadyRegistered` custom rule will only be evaluated when the `email` property passes the `required()` and `email()` validations. Likewise, `usernameNotInUse` will be evaluated only when the `required()`, `minLength(3)` and `maxLength(50)` checks pass validation.\r\n\r\n### Tagging Rules\r\n\r\nUse the `.tag(tag: string)` method to tag a specific property rule with a name. You can retrieve rules with a specific tag using `let someRules = ValidationRules.taggedRules(rules, tag)`. This can come in handy when you want to execute a specific rule or subset of rules. The documentation for the ValidationController (below) shows how to validate specific objects/properties/rules. You can also use the subset of rules with the Validator API (also documented below).\r\n\r\n### on\r\n\r\nOnce your ruleset has been defined you can apply them to a class using the `.on` method. This will ensure the validation engine can locate the rules when evaluating a particular object.\r\n\r\n<code-listing heading=\"Applying Rules to a Class\">\r\n  <source-code lang=\"ES 2015\">\r\n    export class Person {\r\n      firstName = '';\r\n      lastName = '';\r\n    }\r\n\r\n    ValidationRules\r\n      .ensure('firstName').required()\r\n      .ensure('lastName').required()\r\n      .on(Person);\r\n  </source-code>\r\n</code-listing>\r\n\r\n`.on` can apply the rules to a plain JavaScript object as well:\r\n\r\n<code-listing heading=\"Applying Rules to an Object\">\r\n  <source-code lang=\"ES 2015\">\r\n    let patient = {\r\n      firstName: '',\r\n      lastName: ''\r\n    };\r\n\r\n    ValidationRules\r\n      .ensure('firstName').required()\r\n      .ensure('lastName').required()\r\n      .on(patient);\r\n  </source-code>\r\n</code-listing>\r\n\r\nThere is no requirement to apply the rules directly to an object or class, you can capture the ruleset in a variable or property using `.rule` instead:\r\n\r\n<code-listing heading=\"Storing Rules in a Property\">\r\n  <source-code lang=\"ES 2015\">\r\n    const personRules = ValidationRules\r\n      .ensure('firstName').required()\r\n      .ensure('lastName').required()\r\n      .rules;\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Customizing Messages](aurelia-doc://section/3/version/1.0.0)\r\n\r\nThe previous section showed how to customize the message of an individual property rule. You can override messages system-wide by replacing a rule's default message in the `validationMessages` dictionary:\r\n\r\n<code-listing heading=\"Overriding Messages\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {validationMessages} from 'aurelia-validation';\r\n\r\n    validationMessages['required'] = `\\${$displayName} is missing!`;\r\n  </source-code>\r\n</code-listing>\r\n\r\nYou can override the `ValidationMessageProvider`'s `getMessage(key: string): Expression` method to enable more dynamic message logic:\r\n\r\n<code-listing heading=\"Overriding getMessage\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {ValidationMessageProvider} from 'aurelia-validation';\r\n\r\n    ValidationMessageProvider.prototype.standardGetMessage = ValidationMessageProvider.prototype.getMessage;\r\n    ValidationMessageProvider.prototype.getMessage = function(key) {\r\n      const translation = i18next.t(key);\r\n      return this.parser.parseMessage(translation);\r\n    };\r\n  </source-code>\r\n</code-listing>\r\n\r\nYou can also override the `ValidationMessageProvider`'s `getDisplayName(propertyName: string, displayName: string): string` method:\r\n\r\n<code-listing heading=\"Overriding getDisplayName\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {ValidationMessageProvider} from 'aurelia-validation';\r\n\r\n    ValidationMessageProvider.prototype.getDisplayName = function(propertyName, displayName) {\r\n      if (displayName !== null && displayName !== undefined) {\r\n        return displayName;\r\n      }\r\n      return i18next.t(propertyName);\r\n    };\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Validation Controller](aurelia-doc://section/4/version/1.0.0)\r\n\r\nThe `ValidationController` orchestrates the UI process of validating properties in response to various triggers and surfacing validation errors via renderers. Typically you'll have one validation controller instance per \"form\" view model. Depending on the use-case you may have multiple.\r\n\r\n### Creating a Controller\r\n\r\nValidation controllers can be created using the `NewInstance` resolver:\r\n\r\n<code-listing heading=\"Creating a Controller\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {inject, NewInstance} from 'aurelia-dependency-injection';\r\n    import {ValidationController} from 'aurelia-validation';\r\n\r\n    @inject(NewInstance.of(ValidationController))\r\n    export class RegistrationForm {\r\n      controller = null;\r\n\r\n      constructor(controller) {\r\n        this.controller = controller;\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nOr with the `ValidationControllerFactory`:\r\n\r\n<code-listing heading=\"Creating a Controller\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {ValidationControllerFactory} from 'aurelia-validation';\r\n\r\n    @inject(ValidationControllerFactory)\r\n    export class RegistrationForm {\r\n      controller = null;\r\n\r\n      constructor(controllerFactory) {\r\n        this.controller = controllerFactory.createForCurrentScope();\r\n      }\r\n    }\r\n  </source-code>\r\n  <source-code lang=\"TypeScript\">\r\n    import {autoinject} from 'aurelia-dependency-injection';\r\n    import {ValidationControllerFactory, ValidationController} from 'aurelia-validation';\r\n\r\n    @autoinject\r\n    export class RegistrationForm {\r\n      controller: ValidationController;\r\n\r\n      constructor(controllerFactory: ValidationControllerFactory) {\r\n        this.controller = controllerFactory.createForCurrentScope();\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nBoth techniques create a new instance of a `ValidationController` and register the instance in the component's container enabling other components in the validation library to access the approriate controller instance without needing a lot of boilerplate code or markup.\r\n\r\nIf you'd like to be completely explicit when wiring up controllers with view models and bindings, or if you need to use multiple controllers in your component, you can use the `Factory` resolver or the `ValidationControllerFactory`'s `create` method to create controller instances. Using these approaches will not automatically register the controller instance in the container which will prevent the automatic wire-up of controllers with bindings and renderers and will force you to specify the controller instance in your bindings and add renderers to the controller manually.\r\n\r\n### Setting the Validate Trigger\r\n\r\nOnce you've created a controller you can set its `validationTrigger` to either `blur`, `change`, `changeOrBlur` or `manual`. The default is `blur` which means the validation controller will validate the property accessed in a binding when the binding's associated element \"blurs\" (loses focus).\r\n\r\nWhen the trigger is `change`, each change the binding makes to the model property will trigger validation of the property. Use the `throttle`, `debounce` and `updateTrigger` binding behaviors in conjunction with the `change` validate trigger to customize the behavior.\r\n\r\nUse the `manual` trigger to indicate the controller should not automatically validate properties used in bindings. Errors will only be displayed when you invoke the controller's `validate` method and will be cleared when you invoke the controller's `reset` method.\r\n\r\n<code-listing heading=\"Setting the validate trigger\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {ValidationControllerFactory, validateTrigger} from 'aurelia-validation';\r\n\r\n    @inject(ValidationControllerFactory)\r\n    export class RegistrationForm {\r\n      controller = null;\r\n\r\n      constructor(validationControllerFactory) {\r\n        this.controller = validationControllerFactory.createForCurrentScope();\r\n\r\n        this.controller.validateTrigger = validateTrigger.manual;\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\n### validate & reset\r\n\r\nYou can force the validation controller to run validation by invoking the `validate()` method. Validate will run the validation, render the results and return a `Promise` that resolves with a `ControllerValidateResult` instance. *The promise will only reject when there is an unexpected application error. Be sure to catch these rejections like you would any other unexpected application error.*\r\n\r\nInvoking the validate method with no arguments will validate all bindings and objects registered with the controller. You can supply a validate instruction to limit the validation to a specific object, property and ruleset:\r\n\r\n<code-listing heading=\"validate\">\r\n  <source-code lang=\"ES 2015\">\r\n    controller.validate();\r\n    controller.validate({ object: person });\r\n    controller.validate({ object: person, rules: myRules });\r\n    controller.validate({ object: person, propertyName: 'firstName' });    \r\n    controller.validate({ object: person, propertyName: 'firstName', rules: myRules });\r\n\r\n    controller.validate()\r\n      .then(result => {\r\n        if (result.valid) {\r\n          // validation succeeded\r\n        } else {\r\n          // validation failed\r\n        }\r\n      });\r\n  </source-code>\r\n</code-listing>\r\n\r\nMost of the time you will use the `ControllerValidateResult` instance's `valid` property to determine whether validation passed or failed. Use the `results` property to access the `ValidateResult` for every rule that was evaluated by the `controller.validate(...)` call. Each `ValidateResult` has it's own `rule` and `valid` properties that will tell you whether a particular rule passed or failed, along with `message`, `object` and `propertyName` properties.\r\n\r\nThe opposite of the `validate` method is `reset`. Calling reset with no arguments will unrender any previously rendered validation results. You can supply a reset instruction to limit the reset to a specific object or property:\r\n\r\n<code-listing heading=\"reset\">\r\n  <source-code lang=\"ES 2015\">\r\n    controller.reset();\r\n    controller.reset({ object: person });\r\n    controller.reset({ object: person, propertyName: 'firstName' });\r\n  </source-code>\r\n</code-listing>\r\n\r\n### addError & removeError\r\n\r\nYou may need to surface validation errors from other sources. Perhaps while attempting to save a change the server returned a business rule error. You can display the server error using the controller's `addError(message: string, object: any, propertyName?: string): ValidateResult` method. The method returns a `ValidateResult` instance which can be used to unrender the error using `removeError(result: ValidateResult)`.\r\n\r\n### addRenderer & removeRenderer\r\n\r\nThe validation controller renders errors by sending them to implementations of the `ValidationRenderer` interface. The library ships with a built-in renderer that \"renders\" the errors to an array property for data-binding/templating purposes. This is covered in the [displaying errors](aurelia-doc://section/11/version/1.0.0) section below. You can create your own [custom renderer](aurelia-doc://section/12/version/1.0.0) and add it to the controller's set of renderers using the `addRenderer(renderer)` method.\r\n\r\n### Events\r\n\r\nThe validation controller has a `subscribe(callback: (event: ValidateEvent) => void)` method you can use to subscribe to validate and reset events. Callbacks will be invoked whenever the controller's validate and reset methods are called. Callbacks will be passed an instance `ValidateEvent` which contains properties you can use to determine the overall validity state as well as the result of the validate or reset invocation. Refer to the API docs for more info.\r\n\r\n## [Validator](aurelia-doc://section/5/version/1.0.0)\r\n\r\n`Validator` is an interface used by the `ValidationController` to do the behind-the-scenes work of validating objects and properties. The `aurelia-validation` plugin ships with an implementation of this interface called the `StandardValidator`, which knows how to evaluate rules created by `aurelia-validation`'s fluent API. When you use a `Validator` directly to validate a particular object or property, there are no UI side-effects- the validation results are not sent to the the validation renderers.\r\n\r\n### Creating a Validator\r\n\r\nValidators can be injected:\r\n\r\n<code-listing heading=\"Creating a Validator\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {inject} from 'aurelia-dependency-injection';\r\n    import {Validator} from 'aurelia-validation';\r\n\r\n    @inject(Validator)\r\n    export class RegistrationForm {\r\n      validator = null;\r\n\r\n      constructor(validator) {\r\n        this.validator = validator;\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nUse the Validator instance's `validateObject` and `validateProperty` methods to run validation without any render side-effects. These methods return a `Promise` that resolves with an array of `ValidateResults`.\r\n\r\n## [Validate Binding Behavior](aurelia-doc://section/6/version/1.0.0)\r\n\r\nThe `validate` binding behavior enables quick and easy validation for two-way data-bindings. The behavior registers the binding instance with a controller, enabling the system to validate the binding's associated property when the validate trigger occurs (blur / change). The binding behavior is able to identify the object and property name to validate in all sorts of binding expressions:\r\n\r\n<code-listing heading=\"Automatic Binding Validation\">\r\n  <source-code lang=\"HTML\">\r\n    <input type=\"text\" value.bind=\"firstName & validate\">\r\n\r\n    <input type=\"text\" value.bind=\"person.firstName & validate\">\r\n\r\n    <input type=\"text\" value.bind=\"person['firstName'] | upperCase & validate\">\r\n\r\n    <input type=\"text\" value.bind=\"currentEntity[p] & debounce & validate\">    \r\n  </source-code>\r\n</code-listing>\r\n\r\n`validate` accepts a couple of optional arguments enabling you to explicitly specify the rules and controller instance:\r\n\r\n<code-listing heading=\"Explicit Binding Validation\">\r\n  <source-code lang=\"HTML\">\r\n    <input type=\"text\" value.bind=\"firstName & validate:personController\">\r\n\r\n    <input type=\"text\" value.bind=\"firstName & validate:personRules\">\r\n\r\n    <input type=\"text\" value.bind=\"firstName & validate:personController:personRules\">\r\n  </source-code>\r\n</code-listing>\r\n\r\nThe `validate` binding behavior obeys the associated controller's `validateTrigger` (`blur`, `change`, `changeOrBlur`, `manual`). If you'd like to use a different `validateTrigger` in a particular binding use one of the following binding behaviors in place of `& validate`:\r\n\r\n* `& validateOnBlur`: the DOM blur event triggers validation.\r\n* `& validateOnChange`: data entry that changes the model triggers validation.\r\n* `& validateOnChangeOrBlur`: DOM blur or data entry triggers validation.\r\n* `& validateManually`: the binding is not validated automatically when the associated element is blurred or changed by the user.\r\n\r\n## [Displaying Errors](aurelia-doc://section/7/version/1.0.0)\r\n\r\nThe controller exposes properties that are useful for creating error UIs using standard Aurelia templating techniques:\r\n\r\n* `results`: An array of the current `ValidateResult` instances. These are the results of validating individual rules.\r\n* `errors`: An array of the current `ValidateResult` instances whose `valid` property is false.\r\n* `validating`: a boolean that indicates whether the controller is currently executing validation.\r\n\r\nAssuming your view-model had a controller property you could add a simple error summary to your form using a repeat:\r\n\r\n<code-listing heading=\"Simple Validation Summary\">\r\n  <source-code lang=\"HTML\">\r\n    <form>\r\n      <ul if.bind=\"controller.errors\">\r\n        <li repeat.for=\"error of controller.errors\">\r\n          ${error.message}\r\n        </li>\r\n      </ul>\r\n      ...\r\n      ...\r\n    </form>\r\n  </source-code>\r\n</code-listing>\r\n\r\nTo build more sophisticated error UIs you might need a list of errors specific to a particular binding or set of bindings. The `validation-errors` custom attribute creates an array containing all validation errors relevant to the element the `validation-errors` attribute appears on and its descendent elements. Here's an example using bootstrap style form markup:\r\n\r\n<code-listing heading=\"validation-errors custom attribute\">\r\n  <source-code lang=\"HTML\">\r\n    <form>\r\n      <div class=\"form-group\" validation-errors.bind=\"firstNameErrors\"\r\n           class.bind=\"firstNameErrors.length ? 'has-error' : ''\">\r\n        <label for=\"firstName\">First Name</label>\r\n        <input type=\"text\" class=\"form-control\" id=\"firstName\"\r\n               placeholder=\"First Name\"\r\n               value.bind=\"firstName & validate\">\r\n        <span class=\"help-block\" repeat.for=\"errorInfo of firstNameErrors\">\r\n          ${errorInfo.error.message}\r\n        </span>\r\n      </div>\r\n\r\n      <div class=\"form-group\" validation-errors.bind=\"lastNameErrors\"\r\n           class.bind=\"lastNameErrors.length ? 'has-error' : ''\">\r\n        <label for=\"lastName\">Last Name</label>\r\n        <input type=\"text\" class=\"form-control\" id=\"lastName\"\r\n               placeholder=\"Last Name\"\r\n              value.bind=\"lastName & validate\">\r\n        <span class=\"help-block\" repeat.for=\"errorInfo of lastNameErrors\">\r\n          ${errorInfo.error.message}\r\n        </span>\r\n      </div>\r\n    </form>\r\n  </source-code>\r\n</code-listing>\r\n\r\nThis first form-group div uses the `validation-errors` custom attribute to create a `firstNameErrors` property. When there are items in the array the bootstrap `has-error` class is applied to the form-group div. Each error message is displayed below the input using `help-block` spans. The same approach is used to display the lastName field's errors.\r\n\r\nThe `validation-errors` custom attribute implements the `ValidationRenderer` interface. Instead of doing direct DOM manipulation to display the errors it \"renders\" the errors to an array property to enable the data-binding and templating scenarios illustrated above. It also automatically adds itself to the controller using `addRenderer` when its \"bind\" lifecycle event occurs and removes itself from the controller using the `removeRenderer` method when its \"unbind\" composition lifecycle event occurs.\r\n\r\n## [Custom Renderers](aurelia-doc://section/8/version/1.0.0)\r\n\r\nThe templating approaches described in the previous section may require more markup than you wish to include in your templates. If you would prefer use direct DOM manipulation to render validation errors you can implement a custom renderer.\r\n\r\nCustom renderers implement a one-method interface: `render(instruction: RenderInstruction)`. The `RenderInstruction` is an object with two properties: the results to render and the results to unrender. Below is an example implementation for bootstrap forms:\r\n\r\n<code-listing heading=\"bootstrap-form-renderer.ts\">\r\n  <source-code lang=\"TypeScript\">\r\n    import {\r\n      ValidationRenderer,\r\n      RenderInstruction,\r\n      ValidateResult\r\n    } from 'aurelia-validation';\r\n\r\n    export class BootstrapFormRenderer {\r\n      render(instruction: RenderInstruction) {\r\n        for (let { result, elements } of instruction.unrender) {\r\n          for (let element of elements) {\r\n            this.remove(element, result);\r\n          }\r\n        }\r\n\r\n        for (let { result, elements } of instruction.render) {\r\n          for (let element of elements) {\r\n            this.add(element, result);\r\n          }\r\n        }\r\n      }\r\n\r\n      add(element: Element, result: ValidateResult) {\r\n        if (result.valid) {\r\n          return;\r\n        }\r\n\r\n        const formGroup = element.closest('.form-group');\r\n        if (!formGroup) {\r\n          return;\r\n        }\r\n\r\n        // add the has-error class to the enclosing form-group div\r\n        formGroup.classList.add('has-error');\r\n\r\n        // add help-block\r\n        const message = document.createElement('span');\r\n        message.className = 'help-block validation-message';\r\n        message.textContent = result.message;\r\n        message.id = `validation-message-${result.id}`;\r\n        formGroup.appendChild(message);\r\n      }\r\n\r\n      remove(element: Element, result: ValidateResult) {\r\n        if (result.valid) {\r\n          return;\r\n        }\r\n\r\n        const formGroup = element.closest('.form-group');\r\n        if (!formGroup) {\r\n          return;\r\n        }\r\n\r\n        // remove help-block\r\n        const message = formGroup.querySelector(`#validation-message-${result.id}`);\r\n        if (message) {\r\n          formGroup.removeChild(message);\r\n\r\n          // remove the has-error class from the enclosing form-group div\r\n          if (formGroup.querySelectorAll('.help-block.validation-message').length === 0) {\r\n            formGroup.classList.remove('has-error');\r\n          }\r\n        }\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nTo use a custom renderer you'll need to instantiate it and pass it to your controller via the `addRenderer` method. Any of the controller's existing errors will be renderered immediately. You can remove a renderer using the `removeRenderer` method. Removing a renderer will unrender any errors that renderer had previously rendered. If you choose to call `addRenderer` in your view-model's `activate` or `bind` methods, make sure to call `removeRenderer` in the corresponding `deactivate` or `unbind` methods.\r\n\r\n\r\n> Warning\r\n> The renderer example uses `Element.closest`. You'll need to [polyfill](https://github.com/jonathantneal/closest) this method in Internet Explorer.\r\n\r\nHere's another renderer for bootstrap forms that demonstrates \"success styling\". When a property transitions from indeterminate validity to valid or from invalid to valid, the form control will highlight in green. When a property transitions from indeterminate validity to invalid or from valid to invalid, the form control will highlight in red, just like in the previous bootstrap form renderer example.\r\n\r\n<code-listing heading=\"bootstrap-form-renderer.ts\">\r\n  <source-code lang=\"TypeScript\">\r\n    export class BootstrapFormRenderer {\r\n      render(instruction: RenderInstruction) {\r\n        for (let { result, elements } of instruction.unrender) {\r\n          for (let element of elements) {\r\n            this.remove(element, result);\r\n          }\r\n        }\r\n\r\n        for (let { result, elements } of instruction.render) {\r\n          for (let element of elements) {\r\n            this.add(element, result);\r\n          }\r\n        }\r\n      }\r\n\r\n      add(element: Element, result: ValidateResult) {\r\n        const formGroup = element.closest('.form-group');\r\n        if (!formGroup) {\r\n          return;\r\n        }\r\n\r\n        if (result.valid) {\r\n          if (!formGroup.classList.contains('has-error')) {\r\n            formGroup.classList.add('has-success');\r\n          }\r\n        } else {\r\n          // add the has-error class to the enclosing form-group div\r\n          formGroup.classList.remove('has-success');\r\n          formGroup.classList.add('has-error');\r\n\r\n          // add help-block\r\n          const message = document.createElement('span');\r\n          message.className = 'help-block validation-message';\r\n          message.textContent = result.message;\r\n          message.id = `validation-message-${result.id}`;\r\n          formGroup.appendChild(message);\r\n        }\r\n      }\r\n\r\n      remove(element: Element, result: ValidateResult) {\r\n        const formGroup = element.closest('.form-group');\r\n        if (!formGroup) {\r\n          return;\r\n        }\r\n\r\n        if (result.valid) {\r\n          if (formGroup.classList.contains('has-success')) {\r\n            formGroup.classList.remove('has-success');\r\n          }\r\n        } else {\r\n          // remove help-block\r\n          const message = formGroup.querySelector(`#validation-message-${result.id}`);\r\n          if (message) {\r\n            formGroup.removeChild(message);\r\n\r\n            // remove the has-error class from the enclosing form-group div\r\n            if (formGroup.querySelectorAll('.help-block.validation-message').length === 0) {\r\n              formGroup.classList.remove('has-error');\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Entity Validation](aurelia-doc://section/9/version/1.0.0)\r\n\r\nThe examples so far show the controller validating specific properties used in `& validate` bindings. The controller can validate whole entities even if some of the properties aren't used in data bindings. Opt in to this \"entity\" style validation using the controller's `addObject(object, rules?)` method. Calling `addObject` will add the specified object to the set of objects the controller should validate when its `validate` method is called. The `rules` parameter is optional. Use it when the rules for the object haven't been specified using the fluent syntax's `.on` method. You can remove objects from the controller's list of objects to validate using `removeObject(object)`. Calling `removeObject` will unrender any errors associated with the object.\r\n\r\nYou may have rules that are not associated with a single property. The fluent rule syntax has an `ensureObject()` method you can use to define rules for the whole object.\r\n\r\n <code-listing heading=\"ensureObject\">\r\n  <source-code lang=\"ES 2015\">\r\n    export class Shipment {\r\n      length = 0;\r\n      width = 0;\r\n      height = 0;\r\n    }\r\n\r\n    ValidationRules\r\n      .ensureObject()\r\n        .satisfies(obj => obj.length * obj.width * obj.height <= 50)\r\n          .withMessage('Volume cannot be greater than 50 cubic centemeters.')\r\n      .on(Shipment);\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Custom Rules](aurelia-doc://section/10/version/1.0.0)\r\n\r\nThe fluent API's `satisfies` method enables quick custom rules. If you have a custom rule that you need to use multiple times you can define it using the `customRule` method. Once defined, you can apply the rule using `satisfiesRule`.  Here's how you could define and use a simple date validation rule:\r\n\r\n<code-listing heading=\"customRule\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules.customRule(\r\n      'date',\r\n      (value, obj) => value === null || value === undefined || value instanceof Date,\r\n      `\\${$displayName} must be a Date.`\r\n    );\r\n\r\n    ValidationRules\r\n      .ensure('startDate')\r\n        .required()\r\n        .satisfiesRule('date');\r\n  </source-code>\r\n</code-listing>\r\n\r\nYou will often need to pass arguments to your custom rule. Below is an example of an \"integer range\" rule that accepts \"min\" and \"max\" arguments. Notice the last parameter to the `customRule` method packages up the expected parameters into a \"config\" object. The config object is used when computing the validation message when an error occurs, enabling the message expression to access the rule's configuration.\r\n\r\n<code-listing heading=\"customRule\">\r\n  <source-code lang=\"ES 2015\">\r\n    ValidationRules.customRule(\r\n      'integerRange',\r\n      (value, obj, min, max) => value === null || value === undefined\r\n        || Number.isInteger(value) && value >= min && value <= max,\r\n      `\\${$displayName} must be an integer between \\${$config.min} and \\${$config.max}.`,\r\n      (min, max) => ({ min, max })\r\n    );\r\n\r\n    ValidationRules\r\n      .ensure('volume')\r\n        .required()\r\n        .satisfiesRule('integerRange', 1, 5000);\r\n  </source-code>\r\n</code-listing>\r\n\r\nYou may have noticed the custom rule examples above consider `null` and `undefined` to be valid. This is intentional- **a rule should follow the single responsibility principle** and validate only one constraint. It's the `.required()` rule's job to validate whether the data is filled in, you shouldn't add required checking logic to your custom rule for two reasons:\r\n\r\n1. Rule reuse- if our \"integerRange\" rule also does \"required\" checks, we can't use it on optional fields.\r\n2. Messages Relevance- if our \"integerRange\" rule also does \"required\" checks the user will get \"range\" error messages when we they should have gotten \"required\" error messages.\r\n\r\nWhen you write a custom rule, the function should return `true` when the rule is \"satisfied\" / \"valid\" and `false` when the rule is \"broken\" / \"invalid\". Optionally you can return a `Promise` that resolves to `true` or `false`. The promise should not reject unless there's an unexpected exception. Promise rejection is not used for control flow or to represent \"invalid\" status.\r\n\r\nA common application of a custom rule is to confirm that two password entries match.  Here is a example showing how you can do that:\r\n\r\n<code-listing heading=\"confirm password entries match\">\r\n  <source-code lang=\"ES 2015\">\r\n      ValidationRules.customRule(\r\n        'matchesProperty',\r\n        (value, obj, otherPropertyName) =>\r\n          value === null\r\n          || value === undefined\r\n          || value === ''\r\n          || obj[otherPropertyName] === null\r\n          || obj[otherPropertyName] === undefined\r\n          || obj[otherPropertyName] === ''\r\n          || value === obj[otherPropertyName],\r\n        '${$displayName} must match ${$getDisplayName($config.otherPropertyName)}', otherPropertyName => ({ otherPropertyName })\r\n      );\r\n\r\n      ValidationRules\r\n        .ensure(a => a.password)\r\n          .required()\r\n        .ensure(a => a.confirmPassword)\r\n          .required()\r\n          .satisfiesRule('matchesProperty', 'password');\r\n  </source-code>\r\n</code-listing>\r\n\r\n<code-listing heading=\"confirm password entries match\">\r\n  <source-code lang=\"HTML\">\r\n    <div class=\"form-group\">\r\n      <label class=\"control-label\" for=\"password\">Password</label>\r\n      <input type=\"password\" class=\"form-control\" id=\"password\" placeholder=\"Password\"\r\n             value.bind=\"password & validate\"\r\n             change.delegate=\"confirmPassword = ''\">\r\n    </div>\r\n\r\n    <div class=\"form-group\">\r\n      <label class=\"control-label\" for=\"confirmPassword\">Confirm Password</label>\r\n      <input type=\"password\" class=\"form-control\" id=\"confirmPassword\" placeholder=\"Confirm Password\"\r\n             value.bind=\"confirmPassword & validate\">\r\n    </div>\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Multiple Validation Controllers](aurelia-doc://section/11/version/1.0.0)\r\n\r\nIf you have two forms that need to be independently validated, it is of course recommended you implement them in separate components. However, it is technically possible to do two or more independant validations in the same component by creating multiple validation controllers.\r\n\r\nFor instance: imagine you're building an order form for an Italian restaurant. The customer can order pizza or pasta. If the customer makes a mistake in ordering a pizza, they should be able to order a pasta regardless. In that case your view model would look like this:\r\n\r\n<code-listing heading=\"ViewModel with multiple validation controllers\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {inject, NewInstance} from 'aurelia-framework';\r\n    import {ValidationController, ValidationRules} from 'aurelia-validation';\r\n\r\n    @inject(NewInstance.of(ValidationController), NewInstance.of(ValidationController))\r\n    export class ItalianRestaurant {\r\n      pizza;\r\n      pasta;\r\n\r\n      pizzaValidationController;\r\n      pastaValidationController\r\n\r\n      constructor(pizzaValidationController, pastaValidationController) {\r\n        this.pizzaValidationController = pizzaValidationController;\r\n        this.pastaValidationController = pastaValidationController;\r\n\r\n        const pizzaRules = ValidationRules\r\n          .ensure((res: ItalianRestaurant) => res.pizza).required()\r\n          .rules;\r\n        this.pizzaValidationController.addObject(this, pizzaRules);\r\n\r\n        const pastaRules = ValidationRules\r\n          .ensure((res: ItalianRestaurant) => res.pasta).required()\r\n          .rules;\r\n        this.pastaValidationController.addObject(this, pastaRules);\r\n      }\r\n\r\n      orderPizza() {\r\n        this.pizzaValidationController.validate()\r\n          .then(result => {\r\n            if (result.valid) {\r\n              alert(\"Ordering this pizza: \" + this.pizza);\r\n            }\r\n          });\r\n      }\r\n\r\n      orderPasta() {\r\n        this.pastaValidationController.validate()\r\n          .then(result => {\r\n            if (result.valid) {\r\n              alert(\"Ordering this pasta: \" + this.pasta);\r\n            }\r\n          });\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\nIn your view you need to take care to associate each input with the correct validation controller:\r\n\r\n<code-listing heading=\"I18N View\">\r\n  <source-code lang=\"HTML\">\r\n    <template>\r\n      <form validation-errors=\"errors.bind: pizzaErrors; controller.bind: pizzaValidationController\"\r\n            submit.delegate=\"orderPizza()\">\r\n        <label for=\"pizza\">Choose a pizza:</label>\r\n        <input id=\"pizza\" value.bind=\"pizza & validateManually:pizzaValidationController\"/>\r\n        <span class=\"help-block\" repeat.for=\"errorInfo of pizzaErrors\">\r\n          ${errorInfo.error.message}\r\n        </span>\r\n        <input type=\"submit\" value=\"Order pizza!\"/>\r\n      </form>\r\n\r\n      <form validation-errors=\"errors.bind: pastaErrors; controller.bind: pastaValidationController\"\r\n            submit.delegate=\"orderPasta()\">\r\n        <label for=\"pasta\">Choose a pasta:</label>\r\n        <input id=\"pasta\" value.bind=\"pasta & validateManually:pastaValidationController\"/>\r\n        <span class=\"help-block\" repeat.for=\"errorInfo of pastaErrors\">\r\n          ${errorInfo.error.message}\r\n        </span>\r\n        <input type=\"submit\" value=\"Order pasta!\"/>\r\n      </form>\r\n    </template>\r\n  </source-code>\r\n</code-listing>\r\n\r\nIn the forms above you can see that each `validation-errors` attribute and each `validateManually` binding behavior is bound to the appropriate validation controller. This needs to be specified each time, since by default the attribute and the binding behavior will ask the container for a `ValidationController` instance not knowing which one it will get.\r\n\r\n\r\n## [Integration With Other Libraries](aurelia-doc://section/12/version/1.0.0)\r\n\r\nIn `aurelia-validation` the object and property validation work is handled by the `StandardValidator` class which is an implementation of the `Validator` interface. The `StandardValidator` is responsible for applying the rules created with aurelia-validation's fluent syntax. You may not need any of this machinery if you have your own custom validation engine or if you're using a client-side data management library like [Breeze](http://www.getbreezenow.com/breezejs) which has its own validation logic. You can replace the `StandardValidator` with your own implementation when the plugin is installed. Here's an example using breeze:\r\n\r\n <code-listing heading=\"breeze-validator\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {ValidateResult} from 'aurelia-validation';\r\n\r\n    export class BreezeValidator {\r\n      validateObject(object) {\r\n        if (object.entityAspect.validateEntity()) {\r\n          return [];\r\n        }\r\n        return object.entityAspect\r\n          .getValidationErrors()\r\n          .map(({ errorMessage, propertyName, key }) => new ValidateResult(key, object, propertyName, false, errorMessage));\r\n      }\r\n\r\n      validateProperty(object, propertyName) {\r\n        if (object.entityAspect.validateProperty(propertyName)) {\r\n          return [];\r\n        }\r\n        return object.entityAspect\r\n          .getValidationErrors(propertyName)\r\n          .map(({ errorMessage, propertyName, key }) => new ValidateResult(key, object, propertyName, false, errorMessage));\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n<code-listing heading=\"main\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {BreezeValidator} from './breeze-validator';\r\n\r\n    export function configure(aurelia) {\r\n      aurelia.use\r\n        .standardConfiguration()\r\n        .plugin('aurelia-validation', config => config.customValidator(BreezeValidator))\r\n        ...\r\n\r\n      ...\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Integrating with Aurelia-I18N](aurelia-doc://section/13/version/1.0.0)\r\n\r\n`aurelia-i18n` is Aurelia's official I18N plugin. Check out the project's [readme](https://github.com/aurelia/i18n/blob/master/README.md) for information on how to use `aurelia-i18n` in your application.\r\n\r\nIntegrating `aurelia-i18n` with `aurelia-validation` is easy. All standard validation messages are supplied by the `ValidationMessageProvider` class. To translate the messages, override the `getMessage(key)` and `getDisplayName(propertyName, displayName)` methods with implementations that use `aurelia-i18n` to fetch translated versions of the messages/property-names.\r\n\r\nHere's how to override the methods, in your main.js, during application startup:\r\n\r\n<code-listing heading=\"main.js\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {I18N} from 'aurelia-i18n';\r\n    import {ValidationMessageProvider} from 'aurelia-validation';\r\n\r\n    export function configure(aurelia) {\r\n      ...\r\n      ...\r\n\r\n      ValidationMessageProvider.prototype.getMessage = function(key) {\r\n        const i18n = aurelia.container.get(I18N);\r\n        const translation = i18n.tr(`errorMessages.${key}`);\r\n        return this.parser.parseMessage(translation);\r\n      };\r\n\r\n      ValidationMessageProvider.prototype.getDisplayName = function(propertyName, displayName) {\r\n        if (displayName !== null && displayName !== undefined) {\r\n          return displayName;\r\n        }\r\n        const i18n = aurelia.container.get(I18N);\r\n        return i18n.tr(propertyName);\r\n      };\r\n\r\n      ...      \r\n      ...\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\n### Creating the view and view-model\r\n\r\nOnce you've overriden the necessary methods in `ValidationMessageProvider` you're ready to create a view and view-model. Here's a view for a simple multi-language form with first and last name fields. All static text is translated using the [T binding behavior](https://github.com/aurelia/i18n#translating-with-the-tbindingbehavior). Validation occurs on form submission and a switch language button demonstrates the i18n capabilities.\r\n\r\n<code-listing heading=\"I18N View\">\r\n  <source-code lang=\"HTML\">\r\n    <template>\r\n      <form>\r\n        <label>${'firstName' & t}: <br />\r\n          <input type=\"text\" value.bind=\"firstName & validate\" />\r\n        </label>\r\n        <label>${'lastName' & t}: <br />\r\n          <input type=\"text\" value.bind=\"lastName & validate\" />\r\n        </label>\r\n        <button click.delegate=\"submit()\">${'submit' & t}</button>\r\n      </form>\r\n\r\n      <div>\r\n        <h3>${'latestValidationResult' & t}: ${message}</h3>\r\n        <ul if.bind=\"controller.errors.length\">\r\n          <li repeat.for=\"error of controller.errors\">\r\n            ${error.message}\r\n          </li>\r\n        </ul>\r\n      </div>\r\n\r\n\t    <button click.trigger=\"switchLanguage()\">${'switchLanguage' & t}</button>\r\n    <template>   \r\n  </source-code>\r\n</code-listing>\r\n\r\nHere's the view model:\r\n\r\n<code-listing heading=\"I18N ViewModel\">\r\n  <source-code lang=\"ES 2015\">\r\n    import {inject, NewInstance} from 'aurelia-framework';\r\n    import {I18N} from 'aurelia-i18n';\r\n    import {ValidationRules, ValidationController} from 'aurelia-validation';\r\n\r\n    @inject(NewInstance.of(ValidationController), I18N)\r\n    export class App {\r\n      firstName;\r\n      lastName;\r\n\r\n      controller;\r\n      i18n;\r\n      message = '';\r\n\r\n      constructor(controller, i18n) {\r\n        this.controller = controller;\r\n        this.i18n = i18n;\r\n\r\n        ValidationRules\r\n          .ensure((m: App) => m.firstName).required()\r\n          .ensure((m: App) => m.lastName).required()\r\n          .on(this);\r\n      }\r\n\r\n      submit() {\r\n        this.executeValidation();\r\n      }\r\n\r\n      switchLanguage() {\r\n        const currentLocale = this.i18n.getLocale();\r\n        this.i18n.setLocale(currentLocale === 'en' ? 'de' : 'en')\r\n          .then(() => this.executeValidation());\r\n      }\r\n\r\n      executeValidation() {\r\n        this.controller.validate()\r\n          .then(errors => {\r\n            if (errors.length === 0) {\r\n              this.message = this.i18n.tr('allGood');\r\n            } else {\r\n              this.message = this.i18n.tr('youHaveErrors');\r\n            }\r\n          });\r\n      }\r\n    }\r\n  </source-code>\r\n</code-listing>\r\n\r\n### Translation Files\r\n\r\nLast but not least, create translation files that include translations for each propertyName and each validation message key. Below are the German and English files for the example above. Notice the `errorMessages` section has the translation for the `required` rule. In practice, you would need translations for each rule that you use. Take a look at the [`validationMessages` export](https://github.com/aurelia/validation/blob/master/src/implementation/validation-messages.ts) for the full list.\r\n\r\n<code-listing heading=\"Translation files\">\r\n  <source-code lang=\"JSON\">\r\n\t// file: locales/de/translation.json    \r\n\t{\r\n\t  \"firstName\": \"Vorname\",\r\n\t  \"lastName\": \"Nachname\",\r\n\t  \"submit\": \"Abschicken\",\r\n\t  \"switchLanguage\": \"Sprache wechseln\",\r\n\t  \"youHaveErrors\": \"Es gibt Fehler!\",\r\n\t  \"allGood\": \"Alles in Ordnung!\",\r\n\t  \"latestValidationResult\": \"Aktuelles Validierungsergebnis\",\r\n\t  \"errorMessages\": {\r\n\t    \"required\": \"${$displayName} fehlt!\"\r\n\t  }\r\n\t}\r\n\r\n\t// file: locales/en/translation.json\r\n\t{\r\n\t  \"firstName\": \"First name\",\r\n\t  \"lastName\": \"Last name\",\r\n\t  \"submit\": \"Submit\",\r\n\t  \"switchLanguage\": \"Switch language\",\r\n\t  \"youHaveErrors\": \"You have errors!\",\r\n\t  \"allGood\": \"All is good!\",\r\n\t  \"latestValidationResult\": \"Latest validation result\",\r\n\t  \"errorMessages\": {\r\n\t    \"required\": \"${$displayName} is missing!\"\r\n\t  }\r\n\t}\r\n  </source-code>\r\n</code-listing>\r\n\r\n## [Server-Side Validation](aurelia-doc://section/14/version/1.0.0)\r\n\r\nThe fluent rule API and Validator API can be used server-side in a NodeJS application.\r\n\r\n*todo: example*\r\n"}