{"name":"Templating Basics","description":"A basic guide to using Aurelia's templating engine.","author":{"name":"Scott Jackson","url":"http://www.scottmmjackson.com"},"keywords":["JavaScript","Templating","Custom Attributes"],"contributors":[],"translators":[],"links":{"static":"docs/templating/basics","html":"docs/templating/basics/index.html","fragment":"docs/templating/basics/index-fragment.html","self":"docs/templating/basics/index.json"},"content":"\n\n## [Introduction](aurelia-doc://section/1/version/1.0.0)\n\nAurelia's templating system is simple to learn, and yet powerful enough to build even the most complex applications.\nThis article will walk you through the construction of a static template, importing that template into parent\ntemplates, binding and manipulating data through the view-model, and the use of conditionals, repeaters, and events.\n\n## [A Simple Template](aurelia-doc://section/2/version/1.0.0)\n\nAll Aurelia templates must be wrapped with a `<template>` element. The most basic template is a component that prints\n\"Hello World\":\n\n<code-listing heading=\"hello-world.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p>\n    \t  Hello, World!\n      </p>\n    </template>\n  </source-code>\n</code-listing>\n\nThis template could be a page in an Aurelia application, or it could be the view for a custom element. A template\ncontaining only boilerplate could be useful as a footer containing copyright information or disclaimers, but where's\nthe fun in a static template?\n\nAll Aurelia templates work with a view-model, so let's create one:\n\n<code-listing heading=\"hello${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n    export class Hello {\n      constructor() {\n        this.name = 'John Doe';\n      }\n    }\n  </source-code>\n</code-listing>\n\nLet's bind the `name` property in our view-model into our template using Aurelia's string interpolation:\n\n<code-listing heading=\"hello.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p>\n    \t  Hello, ${name}!\n      </p>\n    </template>\n  </source-code>\n</code-listing>\n\nOne of the key features of Aurelia's templating system is helping to reduce context switching between your javascript\ncode and your template markup. String interpolation using the `\\${}` operator is a new feature in ES2015 that makes it\n simple to insert values into a string. Thus, Aurelia uses this standard syntax in your templates.\n\nWhen this template is run, Aurelia will insert the value of the `name` property into the template where `\\${name}`\nappears. Pretty simple, right? But what if we want logic in our string interpolation. Can we add our own expressions?\n Absolutely!\n\n<code-listing heading=\"greeter.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p>\n    \t  ${arriving ? 'Hello' : 'Goodbye'}, ${name}!\n      </p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"greeter${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n    export class Greeter {\n      constructor() {\n        this.name = 'John Doe';\n        this.arriving = true;\n        setTimeout(\n          () => this.arriving = false,\n          5000);\n      }\n    }\n  </source-code>\n</code-listing>\n\nIn our template, when `arriving` is true, the ternary operator makes our result `'Hello'`, but when it's false, it\nmakes our result `'Goodbye'`. Our view-model code initializes `arriving` to `true` and changes it to `false` after 5\nseconds (5000 milliseconds). So when we run the template, it will say \"Hello, John Doe!\" and after 5 seconds, it will\n say \"Goodbye, John Doe!\". Aurelia re-evaluates the string interpolation when the value of `arriving` changes!\n\nBut don't worry, there is no dirty-checking. Aurelia uses an observable-based binding system that reacts to changes\nas they happen without having to do dirty-checking. This means that Aurelia doesn't slow down as you add more complex\n functionality to your template and view-model.\n\n## [Binding](aurelia-doc://section/3/version/1.0.0)\n\nBinding in Aurelia allows data from the view-model to drive template behavior. The most basic example of binding\nis linking a text box to the view model using `value.bind`. What if we let the user decide who they want to greet,\nand whether to say Hello or Goodbye?\n\n<code-listing heading=\"greeter.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <label for=\"nameField\">\n        Who to greet?\n      </label>\n      <input type=\"text\" value.bind=\"name\" id=\"nameField\">\n      <label for=\"arrivingBox\">\n        Arriving?\n      </label>\n      <input type=\"checkbox\" checked.bind=\"arriving\" id=\"arrivingBox\">\n      <p>\n    \t  ${arriving ? 'Hello' : 'Goodbye'}, ${name}!\n      </p>\n    </template>\n  </source-code>\n</code-listing>\n<code-listing heading=\"hello-dynamic-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016\">\n  export class HelloDynamicTemplate {\n    greeting = \"Hello, World!\"\n  }\n  </source-code>\n  <source-code lang=\"TypeScript\">\n  export class HelloDynamicTemplate {\n    greeting = \"Hello, World!\"\n  }\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"greeter${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n    export class Greeter {\n      constructor() {\n        this.name = 'John Doe';\n        this.arriving = true;\n      }\n    }\n  </source-code>\n</code-listing>\n\nAbove, we have a text box that asks for the name of the person to greet, and a checkbox indicating whether they're\narriving. Because we defined `name` as \"John Doe\" in our view-model, the initial value of the text-box will be \"John\nDoe\", and with `arriving` set to `true`, our checkbox will start checked. When we change the name, the person we're\ngreeting will change with it: \"Hello, Jane Doe!\". If we uncheck the box, the greeting will change: \"Goodbye, Jane Doe!\"\n\nNotice that the way we set up the binding was by using `value.bind` and `checked.bind`. That `.` within the attribute is important: whenever you see the `.`, Aurelia is going to do something with that attribute. The most important thing to take away from this section is understanding that Aurelia will link attributes to the left of the `.` with actions to the right of the `.`.\n\nYou can learn more about data-binding in the Binding section of our docs.\n\n### Binding Focus\n\nWe can also use two-way data binding to communicate whether or not an element has focus:\n\n<code-listing heading=\"bind-focus.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <input focus.bind=\"hasFocus\" />\n      ${hasFocus}\n    </template>\n  </source-code>\n</code-listing>\n\nWhen we click the input field, we see \"true\" printed. When we click elsewhere, it changes to \"false\".\n\n### Binding Scopes Using `with`\n\nWe can also declare that certain parts of our markup will be referencing properties of an object in the view model, as below:\n\n<code-listing heading=\"bind-with.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p with.bind=\"first\">\n        <input type=\"text\" value.bind=\"message\" />\n      </p>\n      <p with.bind=\"second\">\n        <input type=\"text\" value.bind=\"message\" />\n      </p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"bind-with${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n    export class Hello {\n      constructor() {\n        this.first = {\n          message : 'Hello'\n        };\n        this.second = {\n          message : 'Goodbye'\n        }\n      }\n    }\n  </source-code>\n</code-listing>\n\nUsing `with` is basically shorthand for \"I'm working on properties of this object\", which lets you reuse code as necessary.\n\n## [Composition](aurelia-doc://section/4/version/1.0.0)\n\nIn order to live by the DRY (Don't Repeat Yourself) Principle, we don't necessarily want to rely on tight coupling\nbetween our view and view-model pairs. Wouldn't it be great if there was a custom element that would arbitrarily combine\nan HTML template, a view-model, and maybe even some initialization data for us? As it turns out, we're in luck:\n\n\n<code-listing heading=\"compose-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <compose view-model=\"hello\"\n               view.bind=\"hello.html\"\n               model.bind=\"{ target : 'World' }\" ></compose>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"hello.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      Hello, ${friend}!\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"hello${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n  export class Hello {\n    activate(model) {\n      this.friend = model.target;\n    }\n  }\n  </source-code>\n</code-listing>\n\nNote that the view-model we're composing into has an `activate` method. When we use `model.bind`, the contents are passed to `activate`. We then pull the exact value that we need out of the passed model and assign it.\n\n## [The as-element Attribute](aurelia-doc://section/5/version/1.0.0)\n\nIn some cases, especially when creating table rows out of Aurelia custom elements, you may need to have a custom element masquerade as a standard HTML element. For example, if you're trying to fill table rows with data, you may need your custom element to appear as a `<tr>` row or `<td>` cell. This is where the `as-element` attribute comes in handy:\n\n<code-listing heading=\"as-element.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"./hello-row.html\"></require>\n      <table>\n        <tr as-element=\"hello-row\">\n      </table>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"hello-row.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <td>Hello</td>\n      <td>World</td>\n    </template>\n  </source-code>\n</code-listing>\n\nThe `as-element` attribute tells Aurelia that we want the content of the table row to be exactly what our `hello-row` template wraps. The way different browsers render tables means this may be necessary sometimes.\n\n## [The View Resource Pipeline](aurelia-doc://section/6/version/1.0.0)\n\nThe basic idea behind the View Resource Pipeline is that we're not limited to HTML or JavaScript. A basic example would be pulling in Bootstrap:\n\n<code-listing heading=\"hello.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <require from=\"bootstrap/css/bootstrap.min.css\"></require>\n      <p class=\"lead\">Hello, World!</p>\n      <p>Lorem Ipsum...</p>\n    </template>\n  </source-code>\n</code-listing>\n\nHere, the `<require>` tag is taking a CSS file, instead of html or a view model. The View Resource Pipeline is the part of Aurelia that's responsible for recognizing that it's CSS, and handling it appropriately. One of the most powerful features of Aurelia is that the View Resource Pipeline is completely extensible, allowing you to define your own handler for any type of view resource you might want to define!\n\n## [View and Compilation Spies](aurelia-doc://section/7/version/1.0.0)\n\nIf you've installed the `aurelia-testing` plugin, you have access to two special templating behaviors:\n\n<code-listing heading=\"hello.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p view-spy compile-spy>Hello!</p>\n    </template>\n  </source-code>\n</code-listing>\n\n`view-spy` drops Aurelia's copy of the View object into the console, while `compile-spy` emits the compiler's TargetInstruction. This is especially useful for debugging any new View Resources you've created using the View Resource Pipeline.\n\n## [Conditionals](aurelia-doc://section/8/version/1.0.0)\n\nAurelia has two major tools for conditional display: `if`, and `show`. The difference is that `if` removes the element\nentirely from the DOM, and `show` toggles the `aurelia-hide` CSS class which controls the element's visibility.\n\nThe difference is subtle but important in terms of speed and usability. When the state changes in `if`, the template\nand all of its children are deleted from the DOM, which is computationally expensive if it's being done over and over.\nHowever, if `show` is being used for a very large template, such as a dashboard containing thousands of elements with\ntheir own bound data, then keeping those elements loaded-but-hidden may not end up being a useful approach.\n\nHere's our basic \"Hello World\" that asks the user if they want to greet the world first:\n\n<code-listing heading=\"if-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <label for=\"greet\">Would you like me to greet the world?</label>\n      <input type=\"checkbox\" id=\"greet\" checked.bind=\"greet\" />\n      <div if.bind=\"greet\">\n        Hello, World!\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nHowever, if we just want to hide the element from view instead of destroying it completely, we should use `show`\ninstead of `if`.\n\n<code-listing heading=\"show-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <label for=\"greet\">Would you like me to greet the world?</label>\n      <input type=\"checkbox\" id=\"greet\" checked.bind=\"greet\" />\n      <div show.bind=\"greet\">\n        Hello, World!\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\nWhen unchecked, our \"Hello World\" div will have the `aurelia-hide` class, which sets `display: none` if you're using\nAurelia's CSS libraries. However, if you don't want to do that, you can also define your own CSS rules that treat\n`aurelia-hide` differently, like setting `visibility: none` or `height: 0px`.\n\nConditionals can also be one-time bound, so that parts of the template are fixed when they're instantiated:\n\n<code-listing heading=\"conditional-one-time-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <div if.one-time=\"greet\">\n        Hello, World!\n      </div>\n      <div if.one-time=\"!greet\">\n        Some other time.\n      </div>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"bind-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016\">\n    export class ConditionalOneTimeTemplate {\n      greet = (Math.random() > 0.5);\n    }\n  </source-code>\n  <source-code lang=\"Typescript\">\n    export class ConditionalOneTimeTemplate {\n      greet = (Math.random() > 0.5);\n    }\n  </source-code>\n</code-listing>\n\nThere's a 50-50 chance that we'll greet the world, or put it off until later. Once the page loads, this is fixed,\nbecause the data is one-time bound. Why don't we use `show.one-time`? If we think about what `show` does, it doesn't\nreally make sense. We're saying we want a CSS class to be applied that will hide an element, and that it will never\nchange. In most cases, we want `if` to refuse to create an element we'll never use.\n\n## [Repeaters](aurelia-doc://section/9/version/1.0.0)\n\nRepeaters can be used on any element, including custom elements, and template elements too! Here are a few different data types that can be iterated with a repeater.\n\n### Arrays\n\nAurelia is also able to repeat elements for each element in an array.\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p repeat.for=\"friend of friends\">Hello, ${friend}!</p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"repeater-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n  export class RepeaterTemplate {\n    constructor() {\n      this.friends = [\n        'Alice',\n        'Bob',\n        'Carol',\n        'Dana'\n      ];\n    }\n  }\n  </source-code>\n</code-listing>\n\nThis allows me to list out my friends and greet them one by one, rather than attempting to greet all 7 billion\ninhabitants of the world at once.\n\nAs mentioned before, we can also use the template element as our repeater - but we have to wrap it in a surrogate `<template>` element:\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <template repeat.for=\"friend of friends\">\n        <p>Hello, ${friend}!</p>\n      </template>\n    </template>\n  </source-code>\n</code-listing>\n\n### Range\n\nWe can also iterate over a numerical range:\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p repeat.for=\"i of 10\">${10-i}</p>\n      <p>Blast off!</p>\n    </template>\n  </source-code>\n</code-listing>\n\nNote that the range will start at 0 with a length of 10, so our countdown really does start at 10 and end at 1 before blast off.\n\n### Sets\n\nI can also use an ES6 Set in the same way:\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p repeat.for=\"friend of friends\">Hello, ${friend}!</p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"repeater-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n  export class RepeaterTemplate {\n    constructor() {\n      this.friends = new Set();\n      this.friends.add('Alice');\n      this.friends.add('Bob');\n      this.friends.add('Carol');\n      this.friends.add('Dana');\n    }\n  }\n  </source-code>\n</code-listing>\n\nWe can use repeaters with arrays, which is useful - but we can also use repeaters with other iterable data types, including objects, plus new ES6 standards such as Map and Set.\n\n### Map\n\nOne of the more useful iterables is the Map, because you can decompose your key and value into two variables directly in the repeater. Although you can repeat over objects straightforwardly, Maps can be two-way bound much more straightforwardly than Objects, so you should try to use Maps where possible.\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p repeat.for=\"[greeting, friend] of friends\">${greeting}, ${friend.name}!</p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"repeater-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n  export class RepeaterTemplate {\n    constructor() {\n      this.friends = new Map();\n      this.friends.set('Hello',\n        { name : 'Alice' });\n      this.friends.set('Hola',\n        { name : 'Bob' });\n      this.friends.set('Ni Hao',\n        { name : 'Carol' });\n      this.friends.set('Molo',\n        { name : 'Dana' });\n    }\n  }\n  </source-code>\n</code-listing>\n\nOne thing to notice in the example above is the dereference operator in `[greeting, friend]` - which breaks apart the map's key-value pair into `greeting`, the key, and `friend`, the value. Note that because all of our values are objects with the `name` property set, we can get our friend's name with `\\${friend.name}`, just as if we were getting it from JavaScript!\n\n### Objects\n\nLet's do the same thing, except with a traditional JavaScript object in our view-model:\n\n<code-listing heading=\"repeater-template.html\">\n  <source-code lang=\"HTML\">\n    <template>\n      <p repeat.for=\"greeting of friends | keys\">${greeting}, ${friends[greeting].name}!</p>\n    </template>\n  </source-code>\n</code-listing>\n\n<code-listing heading=\"repeater-template${context.language.fileExtension}\">\n  <source-code lang=\"ES2015/ES2016/TypeScript\">\n  export class RepeaterTemplate {\n    constructor() {\n      this.friends = {\n        'Hello':\n          { name : 'Alice' },\n        'Hola':\n          { name : 'Bob' },\n        'Ni Hao':\n          { name : 'Carol' },\n        'Molo':\n          { name : 'Dana' }\n      }\n    }\n  }\n\n  export class KeysValueConverter {\n    toView(obj) {\n      return Reflect.ownKeys(obj);\n    }\n  }\n\n  </source-code>\n</code-listing>\n\nWe just introduced something called a \"value converter\". Basically, we take the object in our view model, `friends`, and run it through our `keys` value converter. Aurelia looks for a class named `KeysValueConverter` and tries to call its `toView()` method with our `friends` object. That method returns an array of keys- which we can iterate. In a pinch, we can use this to iterate over Objects.\n\nA common question pops up here: Why can't we just dereference the object into `[key, value]` like we did with Maps? The short answer is that JavaScript objects aren't iterable in the same way that Arrays, Maps, and Sets are. So in order to iterate over JavaScript objects, we have to transform them into something that is iterable. The way you approach it will change based on what exactly you want to do with that object. There is also a [plugin](https://github.com/martingust/aurelia-repeat-strategies) that can be included, which will transform Objects to become iterable maps that can be dereferenced using the `[key, value]` syntax.\n"}